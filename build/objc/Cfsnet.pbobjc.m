// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cfsnet.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Cfsnet.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CFSPBCfsnetRoot

@implementation CFSPBCfsnetRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - CFSPBCfsnetRoot_FileDescriptor

static GPBFileDescriptor *CFSPBCfsnetRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"littlstar.cfsnet"
                                                 objcPrefix:@"CFSPB"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum CFSPBFileMode

GPBEnumDescriptor *CFSPBFileMode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "FOk\000XOk\000WOk\000ROk\000";
    static const int32_t values[] = {
        CFSPBFileMode_FOk,
        CFSPBFileMode_XOk,
        CFSPBFileMode_WOk,
        CFSPBFileMode_ROk,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CFSPBFileMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CFSPBFileMode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CFSPBFileMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case CFSPBFileMode_FOk:
    case CFSPBFileMode_XOk:
    case CFSPBFileMode_WOk:
    case CFSPBFileMode_ROk:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CFSPBErrorCode

GPBEnumDescriptor *CFSPBErrorCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoError\000BadRequestError\000AccessDeniedErro"
        "r\000NotFoundError\000NotSupportedError\000NotOpe"
        "nedError\000InternalError\000NotImplementedErr"
        "or\000";
    static const int32_t values[] = {
        CFSPBErrorCode_NoError,
        CFSPBErrorCode_BadRequestError,
        CFSPBErrorCode_AccessDeniedError,
        CFSPBErrorCode_NotFoundError,
        CFSPBErrorCode_NotSupportedError,
        CFSPBErrorCode_NotOpenedError,
        CFSPBErrorCode_InternalError,
        CFSPBErrorCode_NotImplementedError,
    };
    static const char *extraTextFormatInfo = "\010\000\007\000\001\017\000\002\021\000\003\r\000\004\021\000\005\016\000\006\r\000\007\023\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CFSPBErrorCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CFSPBErrorCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CFSPBErrorCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case CFSPBErrorCode_NoError:
    case CFSPBErrorCode_BadRequestError:
    case CFSPBErrorCode_AccessDeniedError:
    case CFSPBErrorCode_NotFoundError:
    case CFSPBErrorCode_NotSupportedError:
    case CFSPBErrorCode_NotOpenedError:
    case CFSPBErrorCode_InternalError:
    case CFSPBErrorCode_NotImplementedError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CFSPBOperation

GPBEnumDescriptor *CFSPBOperation_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoOperation\000ResolveOperation\000KeyPairOper"
        "ation\000OpenOperation\000CloseOperation\000ReadO"
        "peration\000WriteOperation\000ReadFileOperatio"
        "n\000WriteFileOperation\000StatFileOperation\000U"
        "nlinkFileOperation\000AccessFileOperation\000T"
        "ouchFileOperation\000DownloadFileOperation\000"
        "DownloadDirectoryOperation\000MakeDirectory"
        "Operation\000MakeDirectoryPathOperation\000Rem"
        "oveDirectoryOperation\000RemoveDirectoryPat"
        "hOperation\000ListDirectoryOperation\000";
    static const int32_t values[] = {
        CFSPBOperation_NoOperation,
        CFSPBOperation_ResolveOperation,
        CFSPBOperation_KeyPairOperation,
        CFSPBOperation_OpenOperation,
        CFSPBOperation_CloseOperation,
        CFSPBOperation_ReadOperation,
        CFSPBOperation_WriteOperation,
        CFSPBOperation_ReadFileOperation,
        CFSPBOperation_WriteFileOperation,
        CFSPBOperation_StatFileOperation,
        CFSPBOperation_UnlinkFileOperation,
        CFSPBOperation_AccessFileOperation,
        CFSPBOperation_TouchFileOperation,
        CFSPBOperation_DownloadFileOperation,
        CFSPBOperation_DownloadDirectoryOperation,
        CFSPBOperation_MakeDirectoryOperation,
        CFSPBOperation_MakeDirectoryPathOperation,
        CFSPBOperation_RemoveDirectoryOperation,
        CFSPBOperation_RemoveDirectoryPathOperation,
        CFSPBOperation_ListDirectoryOperation,
    };
    static const char *extraTextFormatInfo = "\024\000\013\000\001\020\000\002\020\000\003\r\000\004\016\000\005\r\000\006\016\000\007\021\000\010\022\000\t\021\000\n\023\000\013\023\000\014\022\000\r\025\000\016\032\000\017\026\000\020\032\000\021\030\000\022\034\000\023\026\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CFSPBOperation)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CFSPBOperation_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CFSPBOperation_IsValidValue(int32_t value__) {
  switch (value__) {
    case CFSPBOperation_NoOperation:
    case CFSPBOperation_ResolveOperation:
    case CFSPBOperation_KeyPairOperation:
    case CFSPBOperation_OpenOperation:
    case CFSPBOperation_CloseOperation:
    case CFSPBOperation_ReadOperation:
    case CFSPBOperation_WriteOperation:
    case CFSPBOperation_ReadFileOperation:
    case CFSPBOperation_WriteFileOperation:
    case CFSPBOperation_StatFileOperation:
    case CFSPBOperation_UnlinkFileOperation:
    case CFSPBOperation_AccessFileOperation:
    case CFSPBOperation_TouchFileOperation:
    case CFSPBOperation_DownloadFileOperation:
    case CFSPBOperation_DownloadDirectoryOperation:
    case CFSPBOperation_MakeDirectoryOperation:
    case CFSPBOperation_MakeDirectoryPathOperation:
    case CFSPBOperation_RemoveDirectoryOperation:
    case CFSPBOperation_RemoveDirectoryPathOperation:
    case CFSPBOperation_ListDirectoryOperation:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CFSPBAccessFile

@implementation CFSPBAccessFile

@dynamic path;
@dynamic mode;

typedef struct CFSPBAccessFile__storage_ {
  uint32_t _has_storage_[1];
  CFSPBFileMode mode;
  NSString *path;
} CFSPBAccessFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBAccessFile_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBAccessFile__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = CFSPBFileMode_EnumDescriptor,
        .number = CFSPBAccessFile_FieldNumber_Mode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBAccessFile__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBAccessFile class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBAccessFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CFSPBAccessFile_Mode_RawValue(CFSPBAccessFile *message) {
  GPBDescriptor *descriptor = [CFSPBAccessFile descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBAccessFile_FieldNumber_Mode];
  return GPBGetMessageInt32Field(message, field);
}

void SetCFSPBAccessFile_Mode_RawValue(CFSPBAccessFile *message, int32_t value) {
  GPBDescriptor *descriptor = [CFSPBAccessFile descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBAccessFile_FieldNumber_Mode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CFSPBBoolean

@implementation CFSPBBoolean

@dynamic value;

typedef struct CFSPBBoolean__storage_ {
  uint32_t _has_storage_[1];
} CFSPBBoolean__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBBoolean_FieldNumber_Value,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBBoolean class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBBoolean__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBBuffer

@implementation CFSPBBuffer

@dynamic value;
@dynamic length;

typedef struct CFSPBBuffer__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
  uint64_t length;
} CFSPBBuffer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBBuffer_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBBuffer__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "length",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBBuffer_FieldNumber_Length,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBBuffer__storage_, length),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBBuffer class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBBuffer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBClose

@implementation CFSPBClose

@dynamic fileDescriptor;

typedef struct CFSPBClose__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fileDescriptor;
} CFSPBClose__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileDescriptor",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBClose_FieldNumber_FileDescriptor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBClose__storage_, fileDescriptor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBClose class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBClose__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBDownloadDirectory

@implementation CFSPBDownloadDirectory

@dynamic path;

typedef struct CFSPBDownloadDirectory__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBDownloadDirectory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBDownloadDirectory_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBDownloadDirectory__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBDownloadDirectory class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBDownloadDirectory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBDownloadFile

@implementation CFSPBDownloadFile

@dynamic path;

typedef struct CFSPBDownloadFile__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBDownloadFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBDownloadFile_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBDownloadFile__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBDownloadFile class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBDownloadFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBDrive

@implementation CFSPBDrive

@dynamic id_p;
@dynamic key;
@dynamic secretKey;

typedef struct CFSPBDrive__storage_ {
  uint32_t _has_storage_[1];
  NSData *id_p;
  NSData *key;
  NSData *secretKey;
} CFSPBDrive__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBDrive_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBDrive__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBDrive_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBDrive__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "secretKey",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBDrive_FieldNumber_SecretKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBDrive__storage_, secretKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBDrive class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBDrive__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBHandshake

@implementation CFSPBHandshake

@dynamic nonce;
@dynamic key;
@dynamic ack;

typedef struct CFSPBHandshake__storage_ {
  uint32_t _has_storage_[1];
  NSData *nonce;
  NSData *key;
} CFSPBHandshake__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBHandshake_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBHandshake__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBHandshake_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBHandshake__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ack",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBHandshake_FieldNumber_Ack,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBHandshake class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBHandshake__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBKeyPair

@implementation CFSPBKeyPair

@dynamic seed;
@dynamic publicKey;
@dynamic secretKey;

typedef struct CFSPBKeyPair__storage_ {
  uint32_t _has_storage_[1];
  NSData *seed;
  NSData *publicKey;
  NSData *secretKey;
} CFSPBKeyPair__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seed",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBKeyPair_FieldNumber_Seed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBKeyPair__storage_, seed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBKeyPair_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBKeyPair__storage_, publicKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "secretKey",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBKeyPair_FieldNumber_SecretKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBKeyPair__storage_, secretKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBKeyPair class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBKeyPair__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\t\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBList

@implementation CFSPBList

@dynamic valuesArray, valuesArray_Count;
@dynamic length;

typedef struct CFSPBList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *valuesArray;
  uint64_t length;
} CFSPBList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBList_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CFSPBList__storage_, valuesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "length",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBList_FieldNumber_Length,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBList__storage_, length),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBList class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBListDirectory

@implementation CFSPBListDirectory

@dynamic path;

typedef struct CFSPBListDirectory__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBListDirectory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBListDirectory_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBListDirectory__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBListDirectory class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBListDirectory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBMakeDirectory

@implementation CFSPBMakeDirectory

@dynamic path;

typedef struct CFSPBMakeDirectory__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBMakeDirectory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBMakeDirectory_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBMakeDirectory__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBMakeDirectory class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBMakeDirectory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBMakeDirectoryPath

@implementation CFSPBMakeDirectoryPath

@dynamic path;

typedef struct CFSPBMakeDirectoryPath__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBMakeDirectoryPath__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBMakeDirectoryPath_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBMakeDirectoryPath__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBMakeDirectoryPath class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBMakeDirectoryPath__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBNumber

@implementation CFSPBNumber

@dynamic value;

typedef struct CFSPBNumber__storage_ {
  uint32_t _has_storage_[1];
  double value;
} CFSPBNumber__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBNumber_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBNumber__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBNumber class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBNumber__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBOpen

@implementation CFSPBOpen

@dynamic path;
@dynamic flags;

typedef struct CFSPBOpen__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
  NSString *flags;
} CFSPBOpen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBOpen_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBOpen__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flags",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBOpen_FieldNumber_Flags,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBOpen__storage_, flags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBOpen class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBOpen__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBRead

@implementation CFSPBRead

@dynamic fileDescriptor;
@dynamic start;
@dynamic end;

typedef struct CFSPBRead__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fileDescriptor;
  uint32_t start;
  uint32_t end;
} CFSPBRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileDescriptor",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBRead_FieldNumber_FileDescriptor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBRead__storage_, fileDescriptor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBRead_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBRead__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBRead_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBRead__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBRead class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBRead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBReadFile

@implementation CFSPBReadFile

@dynamic path;
@dynamic start;
@dynamic end;

typedef struct CFSPBReadFile__storage_ {
  uint32_t _has_storage_[1];
  uint32_t start;
  uint32_t end;
  NSString *path;
} CFSPBReadFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBReadFile_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBReadFile__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBReadFile_FieldNumber_Start,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBReadFile__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBReadFile_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBReadFile__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBReadFile class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBReadFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBRemoveDirectory

@implementation CFSPBRemoveDirectory

@dynamic path;

typedef struct CFSPBRemoveDirectory__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBRemoveDirectory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBRemoveDirectory_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBRemoveDirectory__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBRemoveDirectory class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBRemoveDirectory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBRemoveDirectoryPath

@implementation CFSPBRemoveDirectoryPath

@dynamic path;

typedef struct CFSPBRemoveDirectoryPath__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBRemoveDirectoryPath__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBRemoveDirectoryPath_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBRemoveDirectoryPath__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBRemoveDirectoryPath class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBRemoveDirectoryPath__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBRequest

@implementation CFSPBRequest

@dynamic nonce;
@dynamic hasDrive, drive;
@dynamic operation;
@dynamic buffer;

typedef struct CFSPBRequest__storage_ {
  uint32_t _has_storage_[1];
  CFSPBOperation operation;
  NSData *nonce;
  CFSPBDrive *drive;
  NSData *buffer;
} CFSPBRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBRequest_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBRequest__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "drive",
        .dataTypeSpecific.className = GPBStringifySymbol(CFSPBDrive),
        .number = CFSPBRequest_FieldNumber_Drive,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBRequest__storage_, drive),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "operation",
        .dataTypeSpecific.enumDescFunc = CFSPBOperation_EnumDescriptor,
        .number = CFSPBRequest_FieldNumber_Operation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBRequest__storage_, operation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBRequest_FieldNumber_Buffer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CFSPBRequest__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBRequest class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CFSPBRequest_Operation_RawValue(CFSPBRequest *message) {
  GPBDescriptor *descriptor = [CFSPBRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBRequest_FieldNumber_Operation];
  return GPBGetMessageInt32Field(message, field);
}

void SetCFSPBRequest_Operation_RawValue(CFSPBRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [CFSPBRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBRequest_FieldNumber_Operation];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CFSPBResolve

@implementation CFSPBResolve

@dynamic path;

typedef struct CFSPBResolve__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBResolve__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBResolve_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBResolve__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBResolve class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBResolve__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBResponse

@implementation CFSPBResponse

@dynamic nonce;
@dynamic hasDrive, drive;
@dynamic operation;
@dynamic hasRequest, request;
@dynamic errorCode;
@dynamic buffer;

typedef struct CFSPBResponse__storage_ {
  uint32_t _has_storage_[1];
  CFSPBOperation operation;
  CFSPBErrorCode errorCode;
  NSData *nonce;
  CFSPBDrive *drive;
  CFSPBRequest *request;
  NSData *buffer;
} CFSPBResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBResponse_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBResponse__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "drive",
        .dataTypeSpecific.className = GPBStringifySymbol(CFSPBDrive),
        .number = CFSPBResponse_FieldNumber_Drive,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBResponse__storage_, drive),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "operation",
        .dataTypeSpecific.enumDescFunc = CFSPBOperation_EnumDescriptor,
        .number = CFSPBResponse_FieldNumber_Operation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBResponse__storage_, operation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(CFSPBRequest),
        .number = CFSPBResponse_FieldNumber_Request,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CFSPBResponse__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = CFSPBErrorCode_EnumDescriptor,
        .number = CFSPBResponse_FieldNumber_ErrorCode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CFSPBResponse__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBResponse_FieldNumber_Buffer,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CFSPBResponse__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBResponse class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CFSPBResponse_Operation_RawValue(CFSPBResponse *message) {
  GPBDescriptor *descriptor = [CFSPBResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBResponse_FieldNumber_Operation];
  return GPBGetMessageInt32Field(message, field);
}

void SetCFSPBResponse_Operation_RawValue(CFSPBResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CFSPBResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBResponse_FieldNumber_Operation];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t CFSPBResponse_ErrorCode_RawValue(CFSPBResponse *message) {
  GPBDescriptor *descriptor = [CFSPBResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBResponse_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetCFSPBResponse_ErrorCode_RawValue(CFSPBResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [CFSPBResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFSPBResponse_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CFSPBStat

@implementation CFSPBStat

@dynamic uid;
@dynamic gid;
@dynamic mode;
@dynamic size;
@dynamic atime;
@dynamic ctime;
@dynamic mtime;
@dynamic blocks;

typedef struct CFSPBStat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uid;
  uint32_t gid;
  uint32_t mode;
  uint64_t size;
  uint64_t atime;
  uint64_t ctime;
  uint64_t mtime;
  uint64_t blocks;
} CFSPBStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gid",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Gid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, gid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "mode",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Mode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, mode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "atime",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Atime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, atime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ctime",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Ctime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, ctime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "mtime",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Mtime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, mtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blocks",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStat_FieldNumber_Blocks,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CFSPBStat__storage_, blocks),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBStat class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBStatFile

@implementation CFSPBStatFile

@dynamic path;

typedef struct CFSPBStatFile__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBStatFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBStatFile_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBStatFile__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBStatFile class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBStatFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBString

@implementation CFSPBString

@dynamic value;

typedef struct CFSPBString__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
} CFSPBString__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBString_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBString__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBString class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBString__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBTouchFile

@implementation CFSPBTouchFile

@dynamic path;

typedef struct CFSPBTouchFile__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBTouchFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBTouchFile_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBTouchFile__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBTouchFile class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBTouchFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBUnlinkFile

@implementation CFSPBUnlinkFile

@dynamic path;

typedef struct CFSPBUnlinkFile__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} CFSPBUnlinkFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBUnlinkFile_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBUnlinkFile__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBUnlinkFile class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBUnlinkFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CFSPBWriteFile

@implementation CFSPBWriteFile

@dynamic path;
@dynamic buffer;
@dynamic start;
@dynamic end;

typedef struct CFSPBWriteFile__storage_ {
  uint32_t _has_storage_[1];
  uint32_t start;
  uint32_t end;
  NSString *path;
  NSData *buffer;
} CFSPBWriteFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBWriteFile_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CFSPBWriteFile__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBWriteFile_FieldNumber_Buffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CFSPBWriteFile__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBWriteFile_FieldNumber_Start,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CFSPBWriteFile__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = CFSPBWriteFile_FieldNumber_End,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CFSPBWriteFile__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFSPBWriteFile class]
                                     rootClass:[CFSPBCfsnetRoot class]
                                          file:CFSPBCfsnetRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CFSPBWriteFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
